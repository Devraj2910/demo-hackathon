import { Card } from "../../../domain/entities/card";
import { CardValidationError } from "../../../domain/errors/cardErrors";
import { CardRepository } from "../../../repositories/cardRepository";
import { AddCardRequestDto } from "./addCardRequestDto";
import { AddCardResponseDto } from "./addCardResponseDto";
import { TeamAssignmentRepository } from "../../../../login/repositories/teamAssignmentRepository";

export class AddCard {
  constructor(
    private cardRepository: CardRepository,
    private teamAssignmentRepository: TeamAssignmentRepository
  ) {}

  async execute(request: AddCardRequestDto): Promise<AddCardResponseDto> {
    const { title, content, userId, createdFor } = request;

    // Get user's current team assignment (where effective_to is null)
    const currentTeamAssignment = await this.teamAssignmentRepository.getUserTeamAssignments(userId);
    // const currentTeamAssignment = userTeamAssignments.find(assignment => assignment.effectiveTo === null);
    
    // Create card entity (without ID - will be generated by database)
    const now = new Date();
    const card = Card.create({
      title,
      content,
      userId,
      createdFor,
      teamId: currentTeamAssignment ? currentTeamAssignment[0].teamId.toString() : null,
      createdAt: now,
      updatedAt: now
    });

    // Validate card
    if (!card.validate()) {
      throw new CardValidationError('Invalid card data');
    }

    // Save card to database (ID will be assigned by database)
    const savedCard = await this.cardRepository.save(card);

    // Return response
    return {
      id: savedCard.id as string,
      title: savedCard.title,
      content: savedCard.content,
      userId: savedCard.userId,
      createdFor: savedCard.createdFor,
      teamId: savedCard.teamId,
      createdAt: savedCard.createdAt.toISOString(),
      updatedAt: savedCard.updatedAt.toISOString()
    };
  }
} 